<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Snake</title>
    <style>
      :root {
        color-scheme: light dark;
      }
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        margin: 0;
        min-height: 100vh;
        display: grid;
        gap: 12px;
        padding: 24px;
        justify-items: center;
        align-content: center;
      }
      .layout {
        display: grid;
        grid-template-columns: minmax(160px, 220px) auto minmax(120px, 180px);
        gap: 16px;
        align-items: center;
      }
      .panel {
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-self: start;
      }
      .topbar {
        display: flex;
        gap: 16px;
        justify-content: center;
        margin-bottom: 8px;
      }
      label {
        display: inline-flex;
        gap: 6px;
        align-items: center;
      }
      canvas {
        border: 2px solid #444;
        background: #111;
      }
      #gameOver {
        color: #c00;
        font-weight: 600;
        display: none;
      }
      #paused {
        color: #f39c12;
        font-weight: 600;
        display: none;
      }
      .scoreboard {
        margin-top: 16px;
        text-align: left;
      }
      .scoreboard ol {
        margin: 4px 0 0 18px;
        padding: 0;
      }
      button {
        padding: 4px 10px;
      }
      input[type="number"] {
        width: 64px;
      }
    </style>
  </head>
  <body>
    <div class="layout">
      <div class="panel">
        <label>
          Mute
          <input id="mute" type="checkbox" />
        </label>
        <button id="restartBtn">Restart</button>
        <div id="gameOver">Game Over</div>
        <div class="scoreboard">
          <div>Top 5</div>
          <ol id="scores"></ol>
        </div>
      </div>
      <div>
        <div class="topbar">
          <div>Score: <span id="score">0</span></div>
          <div>High Score: <span id="highScore">0</span></div>
        </div>
        <canvas id="game" width="450" height="450" aria-label="Snake game"></canvas>
      </div>
      <div class="panel">
        <div>Time: <span id="timer">--</span></div>
        <div id="paused">Paused</div>
        <label>
          Grid
          <input id="gridSize" type="number" min="10" max="20" value="15" />
        </label>
        <label>
          Wrap
          <input id="wrapMode" type="checkbox" />
        </label>
        <label>
          Obstacles
          <select id="obstacles">
            <option value="none">None</option>
            <option value="box">Box</option>
            <option value="cross">Cross</option>
          </select>
        </label>
        <label>
          Theme
          <select id="theme">
            <option value="classic">Classic</option>
            <option value="neon">Neon</option>
            <option value="mono">Mono</option>
          </select>
        </label>
        <label>
          Mode
          <select id="mode">
            <option value="normal">Normal</option>
            <option value="time">Time Trial (60s)</option>
          </select>
        </label>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const scoreEl = document.getElementById("score");
      const timerEl = document.getElementById("timer");
      const pausedEl = document.getElementById("paused");
      const gridSizeInput = document.getElementById("gridSize");
      const restartBtn = document.getElementById("restartBtn");
      const gameOverEl = document.getElementById("gameOver");
      const highScoreEl = document.getElementById("highScore");
      const HIGH_SCORE_KEY = "snakeHighScore";
      const SCORES_KEY = "snakeScores";
      const MODE_KEY = "snakeMode";
      const THEME_KEY = "snakeTheme";
      const MUTE_KEY = "snakeMute";
      const wrapModeInput = document.getElementById("wrapMode");
      const obstaclesInput = document.getElementById("obstacles");
      const themeInput = document.getElementById("theme");
      const modeInput = document.getElementById("mode");
      const muteInput = document.getElementById("mute");
      const scoresEl = document.getElementById("scores");

      const THEMES = {
        classic: {
          background: "#111",
          grid: "#222",
          snakeHead: "#55efc4",
          snakeBody: "#00b894",
          food: "#e63946",
          obstacle: "#6c5ce7",
        },
        neon: {
          background: "#0a0f1f",
          grid: "#1b2b4a",
          snakeHead: "#00f5ff",
          snakeBody: "#00c2ff",
          food: "#ff3b3b",
          obstacle: "#f9d423",
        },
        mono: {
          background: "#161616",
          grid: "#2a2a2a",
          snakeHead: "#f5f5f5",
          snakeBody: "#bdbdbd",
          food: "#ffffff",
          obstacle: "#8c8c8c",
        },
      };

      const state = {
        gridSize: 15,
        cellSize: 30,
        snake: [],
        dir: { x: 1, y: 0 },
        nextDir: { x: 1, y: 0 },
        food: { x: 0, y: 0 },
        score: 0,
        highScore: 0,
        wrapMode: false,
        obstacleMode: "none",
        obstacles: [],
        themeName: "classic",
        theme: THEMES.classic,
        isMuted: false,
        audioContext: null,
        audioUnlocked: false,
        timerId: null,
        timerIntervalId: null,
        isPaused: false,
        isGameOver: false,
        baseSpeedMs: 100,
        speedMs: 100,
        minSpeedMs: 50,
        speedStepMs: 10,
        foodsPerSpeedup: 5,
        mode: "normal",
        timeTrialSeconds: 60,
        timeLeft: null,
        scores: [],
      };

      function initGame() {
        state.highScore = getStoredHighScore();
        highScoreEl.textContent = String(state.highScore);
        state.themeName = getStoredTheme();
        applyTheme(state.themeName);
        state.mode = getStoredMode();
        modeInput.value = state.mode;
        state.isMuted = getStoredMute();
        muteInput.checked = state.isMuted;
        state.scores = getStoredScores();
        renderScores();
        const size = clampGridSize(parseInt(gridSizeInput.value, 10));
        state.gridSize = size;
        gridSizeInput.value = String(size);
        state.cellSize = Math.floor(450 / size);
        canvas.width = state.cellSize * size;
        canvas.height = state.cellSize * size;
        reset();
      }

      function reset() {
        state.snake = [
          { x: 2, y: 0 },
          { x: 1, y: 0 },
          { x: 0, y: 0 },
        ];
        state.dir = { x: 1, y: 0 };
        state.nextDir = { x: 1, y: 0 };
        state.score = 0;
        state.speedMs = state.baseSpeedMs;
        state.isPaused = false;
        state.isGameOver = false;
        gameOverEl.style.display = "none";
        pausedEl.style.display = "none";
        scoreEl.textContent = "0";
        updateHighScore(0);
        state.obstacles = buildObstacles(state.obstacleMode);
        startTimer();
        spawnFood();
        startLoop();
        draw();
      }

      function spawnFood() {
        const emptyCells = [];
        for (let y = 0; y < state.gridSize; y += 1) {
          for (let x = 0; x < state.gridSize; x += 1) {
            if (
              !state.snake.some((seg) => seg.x === x && seg.y === y) &&
              !state.obstacles.some((obs) => obs.x === x && obs.y === y)
            ) {
              emptyCells.push({ x, y });
            }
          }
        }
        if (emptyCells.length === 0) {
          return;
        }
        const idx = Math.floor(Math.random() * emptyCells.length);
        state.food = emptyCells[idx];
      }

      function step() {
        if (state.isGameOver || state.isPaused) return;

        state.dir = state.nextDir;
        const head = state.snake[0];
        let next = { x: head.x + state.dir.x, y: head.y + state.dir.y };

        if (state.wrapMode) {
          next = wrapPosition(next);
        } else if (hitsWall(next)) {
          endGame();
          return;
        }

        if (hitsObstacle(next) || hitsSelf(next)) {
          endGame();
          return;
        }

        state.snake.unshift(next);

        if (next.x === state.food.x && next.y === state.food.y) {
          state.score += 1;
          scoreEl.textContent = String(state.score);
          updateHighScore(state.score);
          updateSpeed();
          playSound("eat");
          spawnFood();
        } else {
          state.snake.pop();
        }

        draw();
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();
        state.obstacles.forEach((obs) => drawCell(obs, state.theme.obstacle));
        drawCell(state.food, state.theme.food);
        state.snake.forEach((seg, idx) => {
          drawCell(
            seg,
            idx === 0 ? state.theme.snakeHead : state.theme.snakeBody
          );
        });
      }

      function handleInput(event) {
        const key = event.key;
        if (key.toLowerCase() === "p") {
          togglePause();
        } else if (key === "ArrowUp") {
          setDirection({ x: 0, y: -1 });
        } else if (key === "ArrowDown") {
          setDirection({ x: 0, y: 1 });
        } else if (key === "ArrowLeft") {
          setDirection({ x: -1, y: 0 });
        } else if (key === "ArrowRight") {
          setDirection({ x: 1, y: 0 });
        } else if (key.toLowerCase() === "r") {
          reset();
        }
      }

      function setDirection(next) {
        // Prevent 180-degree instant reversal.
        if (state.dir.x + next.x === 0 && state.dir.y + next.y === 0) {
          return;
        }
        state.nextDir = next;
      }

      function startLoop() {
        if (state.timerId) {
          clearInterval(state.timerId);
        }
        state.timerId = setInterval(step, state.speedMs);
      }

      function updateSpeed() {
        // Increase speed every N foods, down to a minimum delay.
        const tiers = Math.floor(state.score / state.foodsPerSpeedup);
        const nextSpeed = Math.max(
          state.minSpeedMs,
          state.baseSpeedMs - tiers * state.speedStepMs
        );
        if (nextSpeed !== state.speedMs) {
          state.speedMs = nextSpeed;
          startLoop();
        }
      }

      function endGame() {
        if (state.isGameOver) return;
        state.isGameOver = true;
        gameOverEl.style.display = "block";
        pausedEl.style.display = "none";
        recordScore(state.score);
        playSound("gameOver");
      }

      function hitsWall(pos) {
        return (
          pos.x < 0 ||
          pos.y < 0 ||
          pos.x >= state.gridSize ||
          pos.y >= state.gridSize
        );
      }

      function wrapPosition(pos) {
        let x = pos.x;
        let y = pos.y;
        if (x < 0) x = state.gridSize - 1;
        if (x >= state.gridSize) x = 0;
        if (y < 0) y = state.gridSize - 1;
        if (y >= state.gridSize) y = 0;
        return { x, y };
      }

      function hitsSelf(pos) {
        return state.snake.some((seg) => seg.x === pos.x && seg.y === pos.y);
      }

      function hitsObstacle(pos) {
        return state.obstacles.some((obs) => obs.x === pos.x && obs.y === pos.y);
      }

      function drawGrid() {
        ctx.strokeStyle = state.theme.grid;
        for (let i = 0; i <= state.gridSize; i += 1) {
          const p = i * state.cellSize;
          ctx.beginPath();
          ctx.moveTo(p, 0);
          ctx.lineTo(p, canvas.height);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, p);
          ctx.lineTo(canvas.width, p);
          ctx.stroke();
        }
      }

      function drawCell(cell, color) {
        ctx.fillStyle = color;
        ctx.fillRect(
          cell.x * state.cellSize + 1,
          cell.y * state.cellSize + 1,
          state.cellSize - 2,
          state.cellSize - 2
        );
      }

      function clampGridSize(value) {
        if (Number.isNaN(value)) return 15;
        return Math.min(20, Math.max(10, value));
      }

      function getStoredHighScore() {
        const stored = Number(localStorage.getItem(HIGH_SCORE_KEY));
        return Number.isFinite(stored) ? stored : 0;
      }

      function updateHighScore(score) {
        if (score <= state.highScore) return;
        state.highScore = score;
        highScoreEl.textContent = String(state.highScore);
        localStorage.setItem(HIGH_SCORE_KEY, String(score));
      }

      function getStoredScores() {
        try {
          const stored = JSON.parse(localStorage.getItem(SCORES_KEY) || "[]");
          return Array.isArray(stored) ? stored : [];
        } catch {
          return [];
        }
      }

      function renderScores() {
        scoresEl.innerHTML = "";
        state.scores.slice(0, 5).forEach((score) => {
          const li = document.createElement("li");
          li.textContent = String(score);
          scoresEl.appendChild(li);
        });
      }

      function recordScore(score) {
        if (score <= 0) return;
        state.scores = [score, ...state.scores].sort((a, b) => b - a).slice(0, 5);
        localStorage.setItem(SCORES_KEY, JSON.stringify(state.scores));
        renderScores();
      }

      function getStoredTheme() {
        const stored = localStorage.getItem(THEME_KEY);
        return THEMES[stored] ? stored : "classic";
      }

      function applyTheme(name) {
        state.themeName = THEMES[name] ? name : "classic";
        state.theme = THEMES[state.themeName];
        themeInput.value = state.themeName;
        canvas.style.background = state.theme.background;
        draw();
      }

      function getStoredMode() {
        const stored = localStorage.getItem(MODE_KEY);
        return stored === "time" ? "time" : "normal";
      }

      function startTimer() {
        if (state.timerIntervalId) {
          clearInterval(state.timerIntervalId);
          state.timerIntervalId = null;
        }
        if (state.mode !== "time") {
          state.timeLeft = null;
          timerEl.textContent = "--";
          return;
        }
        state.timeLeft = state.timeTrialSeconds;
        timerEl.textContent = String(state.timeLeft);
        state.timerIntervalId = setInterval(() => {
          if (state.isGameOver || state.isPaused) return;
          state.timeLeft -= 1;
          timerEl.textContent = String(state.timeLeft);
          if (state.timeLeft <= 0) {
            endGame();
          }
        }, 1000);
      }

      function togglePause() {
        if (state.isGameOver) return;
        state.isPaused = !state.isPaused;
        pausedEl.style.display = state.isPaused ? "block" : "none";
      }

      function getStoredMute() {
        const stored = localStorage.getItem(MUTE_KEY);
        return stored === "true";
      }

      function ensureAudio() {
        if (state.audioContext) return;
        const AudioContext =
          window.AudioContext || window.webkitAudioContext || null;
        if (!AudioContext) return;
        state.audioContext = new AudioContext();
      }

      function unlockAudio() {
        if (state.audioUnlocked) return;
        ensureAudio();
        if (!state.audioContext) return;
        if (state.audioContext.state === "suspended") {
          state.audioContext.resume();
        }
        state.audioUnlocked = true;
      }

      function playSound(type) {
        if (state.isMuted) return;
        ensureAudio();
        if (!state.audioContext) return;
        if (state.audioContext.state === "suspended") return;

        const now = state.audioContext.currentTime;
        const osc = state.audioContext.createOscillator();
        const gain = state.audioContext.createGain();
        const settings =
          type === "eat"
            ? { freq: 520, duration: 0.08 }
            : { freq: 180, duration: 0.2 };

        osc.type = "square";
        osc.frequency.setValueAtTime(settings.freq, now);
        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(0.2, now + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + settings.duration);

        osc.connect(gain);
        gain.connect(state.audioContext.destination);
        osc.start(now);
        osc.stop(now + settings.duration);
      }

      function buildObstacles(mode) {
        const obstacles = [];
        const size = state.gridSize;
        const mid = Math.floor(size / 2);
        const add = (x, y) => {
          if (x < 0 || y < 0 || x >= size || y >= size) return;
          obstacles.push({ x, y });
        };

        if (mode === "box") {
          // Solid box prevents unreachable food inside a hollow ring.
          for (let y = mid - 2; y <= mid + 2; y += 1) {
            for (let x = mid - 2; x <= mid + 2; x += 1) {
              add(x, y);
            }
          }
        } else if (mode === "cross") {
          for (let i = 2; i < size - 2; i += 1) {
            add(mid, i);
            add(i, mid);
          }
        }

        return obstacles.filter(
          (obs) => !state.snake.some((seg) => seg.x === obs.x && obs.y === obs.y)
        );
      }

      gridSizeInput.addEventListener("change", initGame);
      wrapModeInput.addEventListener("change", (event) => {
        state.wrapMode = event.target.checked;
      });
      obstaclesInput.addEventListener("change", (event) => {
        state.obstacleMode = event.target.value;
        reset();
      });
      themeInput.addEventListener("change", (event) => {
        const name = event.target.value;
        applyTheme(name);
        localStorage.setItem(THEME_KEY, state.themeName);
      });
      modeInput.addEventListener("change", (event) => {
        state.mode = event.target.value;
        localStorage.setItem(MODE_KEY, state.mode);
        reset();
      });
      muteInput.addEventListener("change", (event) => {
        state.isMuted = event.target.checked;
        localStorage.setItem(MUTE_KEY, String(state.isMuted));
      });
      restartBtn.addEventListener("click", reset);
      window.addEventListener("keydown", (event) => {
        unlockAudio();
        handleInput(event);
      });
      window.addEventListener("mousedown", unlockAudio, { once: true });

      initGame();
    </script>
  </body>
</html>
