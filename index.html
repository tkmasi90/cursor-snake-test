<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Snake</title>
    <style>
      :root {
        color-scheme: light dark;
      }
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        margin: 24px;
        display: grid;
        gap: 12px;
        justify-items: start;
      }
      .toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
      }
      label {
        display: inline-flex;
        gap: 6px;
        align-items: center;
      }
      canvas {
        border: 2px solid #444;
        background: #111;
      }
      #gameOver {
        color: #c00;
        font-weight: 600;
        display: none;
      }
      button {
        padding: 4px 10px;
      }
      input[type="number"] {
        width: 64px;
      }
    </style>
  </head>
  <body>
    <div class="toolbar">
      <div>Score: <span id="score">0</span></div>
      <div>High Score: <span id="highScore">0</span></div>
      <label>
        Grid
        <input id="gridSize" type="number" min="10" max="20" value="15" />
      </label>
      <label>
        Wrap
        <input id="wrapMode" type="checkbox" />
      </label>
      <label>
        Obstacles
        <select id="obstacles">
          <option value="none">None</option>
          <option value="box">Box</option>
          <option value="cross">Cross</option>
        </select>
      </label>
      <label>
        Theme
        <select id="theme">
          <option value="classic">Classic</option>
          <option value="neon">Neon</option>
          <option value="mono">Mono</option>
        </select>
      </label>
      <button id="restartBtn">Restart</button>
      <div id="gameOver">Game Over</div>
    </div>
    <canvas id="game" width="450" height="450" aria-label="Snake game"></canvas>

    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const scoreEl = document.getElementById("score");
      const gridSizeInput = document.getElementById("gridSize");
      const restartBtn = document.getElementById("restartBtn");
      const gameOverEl = document.getElementById("gameOver");
      const highScoreEl = document.getElementById("highScore");
      const HIGH_SCORE_KEY = "snakeHighScore";
      const THEME_KEY = "snakeTheme";
      const wrapModeInput = document.getElementById("wrapMode");
      const obstaclesInput = document.getElementById("obstacles");
      const themeInput = document.getElementById("theme");

      const THEMES = {
        classic: {
          background: "#111",
          grid: "#222",
          snakeHead: "#55efc4",
          snakeBody: "#00b894",
          food: "#e63946",
          obstacle: "#6c5ce7",
        },
        neon: {
          background: "#0a0f1f",
          grid: "#1b2b4a",
          snakeHead: "#00f5ff",
          snakeBody: "#00c2ff",
          food: "#ff3b3b",
          obstacle: "#f9d423",
        },
        mono: {
          background: "#161616",
          grid: "#2a2a2a",
          snakeHead: "#f5f5f5",
          snakeBody: "#bdbdbd",
          food: "#ffffff",
          obstacle: "#8c8c8c",
        },
      };

      const state = {
        gridSize: 15,
        cellSize: 30,
        snake: [],
        dir: { x: 1, y: 0 },
        nextDir: { x: 1, y: 0 },
        food: { x: 0, y: 0 },
        score: 0,
        highScore: 0,
        wrapMode: false,
        obstacleMode: "none",
        obstacles: [],
        themeName: "classic",
        theme: THEMES.classic,
        timerId: null,
        isGameOver: false,
        baseSpeedMs: 100,
        speedMs: 100,
        minSpeedMs: 50,
        speedStepMs: 10,
        foodsPerSpeedup: 5,
      };

      function initGame() {
        state.highScore = getStoredHighScore();
        highScoreEl.textContent = String(state.highScore);
        state.themeName = getStoredTheme();
        applyTheme(state.themeName);
        const size = clampGridSize(parseInt(gridSizeInput.value, 10));
        state.gridSize = size;
        gridSizeInput.value = String(size);
        state.cellSize = Math.floor(450 / size);
        canvas.width = state.cellSize * size;
        canvas.height = state.cellSize * size;
        reset();
      }

      function reset() {
        state.snake = [
          { x: 2, y: 0 },
          { x: 1, y: 0 },
          { x: 0, y: 0 },
        ];
        state.dir = { x: 1, y: 0 };
        state.nextDir = { x: 1, y: 0 };
        state.score = 0;
        state.speedMs = state.baseSpeedMs;
        state.isGameOver = false;
        gameOverEl.style.display = "none";
        scoreEl.textContent = "0";
        updateHighScore(0);
        state.obstacles = buildObstacles(state.obstacleMode);
        spawnFood();
        startLoop();
        draw();
      }

      function spawnFood() {
        const emptyCells = [];
        for (let y = 0; y < state.gridSize; y += 1) {
          for (let x = 0; x < state.gridSize; x += 1) {
            if (
              !state.snake.some((seg) => seg.x === x && seg.y === y) &&
              !state.obstacles.some((obs) => obs.x === x && obs.y === y)
            ) {
              emptyCells.push({ x, y });
            }
          }
        }
        if (emptyCells.length === 0) {
          return;
        }
        const idx = Math.floor(Math.random() * emptyCells.length);
        state.food = emptyCells[idx];
      }

      function step() {
        if (state.isGameOver) return;

        state.dir = state.nextDir;
        const head = state.snake[0];
        let next = { x: head.x + state.dir.x, y: head.y + state.dir.y };

        if (state.wrapMode) {
          next = wrapPosition(next);
        } else if (hitsWall(next)) {
          endGame();
          return;
        }

        if (hitsObstacle(next) || hitsSelf(next)) {
          endGame();
          return;
        }

        state.snake.unshift(next);

        if (next.x === state.food.x && next.y === state.food.y) {
          state.score += 1;
          scoreEl.textContent = String(state.score);
          updateHighScore(state.score);
          updateSpeed();
          spawnFood();
        } else {
          state.snake.pop();
        }

        draw();
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();
        state.obstacles.forEach((obs) => drawCell(obs, state.theme.obstacle));
        drawCell(state.food, state.theme.food);
        state.snake.forEach((seg, idx) => {
          drawCell(
            seg,
            idx === 0 ? state.theme.snakeHead : state.theme.snakeBody
          );
        });
      }

      function handleInput(event) {
        const key = event.key;
        if (key === "ArrowUp") {
          setDirection({ x: 0, y: -1 });
        } else if (key === "ArrowDown") {
          setDirection({ x: 0, y: 1 });
        } else if (key === "ArrowLeft") {
          setDirection({ x: -1, y: 0 });
        } else if (key === "ArrowRight") {
          setDirection({ x: 1, y: 0 });
        } else if (key.toLowerCase() === "r") {
          reset();
        }
      }

      function setDirection(next) {
        // Prevent 180-degree instant reversal.
        if (state.dir.x + next.x === 0 && state.dir.y + next.y === 0) {
          return;
        }
        state.nextDir = next;
      }

      function startLoop() {
        if (state.timerId) {
          clearInterval(state.timerId);
        }
        state.timerId = setInterval(step, state.speedMs);
      }

      function updateSpeed() {
        // Increase speed every N foods, down to a minimum delay.
        const tiers = Math.floor(state.score / state.foodsPerSpeedup);
        const nextSpeed = Math.max(
          state.minSpeedMs,
          state.baseSpeedMs - tiers * state.speedStepMs
        );
        if (nextSpeed !== state.speedMs) {
          state.speedMs = nextSpeed;
          startLoop();
        }
      }

      function endGame() {
        state.isGameOver = true;
        gameOverEl.style.display = "block";
      }

      function hitsWall(pos) {
        return (
          pos.x < 0 ||
          pos.y < 0 ||
          pos.x >= state.gridSize ||
          pos.y >= state.gridSize
        );
      }

      function wrapPosition(pos) {
        let x = pos.x;
        let y = pos.y;
        if (x < 0) x = state.gridSize - 1;
        if (x >= state.gridSize) x = 0;
        if (y < 0) y = state.gridSize - 1;
        if (y >= state.gridSize) y = 0;
        return { x, y };
      }

      function hitsSelf(pos) {
        return state.snake.some((seg) => seg.x === pos.x && seg.y === pos.y);
      }

      function hitsObstacle(pos) {
        return state.obstacles.some((obs) => obs.x === pos.x && obs.y === pos.y);
      }

      function drawGrid() {
        ctx.strokeStyle = state.theme.grid;
        for (let i = 0; i <= state.gridSize; i += 1) {
          const p = i * state.cellSize;
          ctx.beginPath();
          ctx.moveTo(p, 0);
          ctx.lineTo(p, canvas.height);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, p);
          ctx.lineTo(canvas.width, p);
          ctx.stroke();
        }
      }

      function drawCell(cell, color) {
        ctx.fillStyle = color;
        ctx.fillRect(
          cell.x * state.cellSize + 1,
          cell.y * state.cellSize + 1,
          state.cellSize - 2,
          state.cellSize - 2
        );
      }

      function clampGridSize(value) {
        if (Number.isNaN(value)) return 15;
        return Math.min(20, Math.max(10, value));
      }

      function getStoredHighScore() {
        const stored = Number(localStorage.getItem(HIGH_SCORE_KEY));
        return Number.isFinite(stored) ? stored : 0;
      }

      function updateHighScore(score) {
        if (score <= state.highScore) return;
        state.highScore = score;
        highScoreEl.textContent = String(score);
        localStorage.setItem(HIGH_SCORE_KEY, String(score));
      }

      function getStoredTheme() {
        const stored = localStorage.getItem(THEME_KEY);
        return THEMES[stored] ? stored : "classic";
      }

      function applyTheme(name) {
        state.themeName = THEMES[name] ? name : "classic";
        state.theme = THEMES[state.themeName];
        themeInput.value = state.themeName;
        canvas.style.background = state.theme.background;
        draw();
      }

      function buildObstacles(mode) {
        const obstacles = [];
        const size = state.gridSize;
        const mid = Math.floor(size / 2);
        const add = (x, y) => {
          if (x < 0 || y < 0 || x >= size || y >= size) return;
          obstacles.push({ x, y });
        };

        if (mode === "box") {
          // Solid box prevents unreachable food inside a hollow ring.
          for (let y = mid - 2; y <= mid + 2; y += 1) {
            for (let x = mid - 2; x <= mid + 2; x += 1) {
              add(x, y);
            }
          }
        } else if (mode === "cross") {
          for (let i = 2; i < size - 2; i += 1) {
            add(mid, i);
            add(i, mid);
          }
        }

        return obstacles.filter(
          (obs) => !state.snake.some((seg) => seg.x === obs.x && seg.y === obs.y)
        );
      }

      gridSizeInput.addEventListener("change", initGame);
      wrapModeInput.addEventListener("change", (event) => {
        state.wrapMode = event.target.checked;
      });
      obstaclesInput.addEventListener("change", (event) => {
        state.obstacleMode = event.target.value;
        reset();
      });
      themeInput.addEventListener("change", (event) => {
        const name = event.target.value;
        applyTheme(name);
        localStorage.setItem(THEME_KEY, state.themeName);
      });
      restartBtn.addEventListener("click", reset);
      window.addEventListener("keydown", handleInput);

      initGame();
    </script>
  </body>
</html>
